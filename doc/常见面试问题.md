## 常见面试问题  

1. 闭包  
2. vue2和vue3双向绑定的区别
3. 数组去重 
4. 什么是vuex 
5. 什么是虚拟dom 
6. keep-alive 
7. router里的history模式和hash模式有什么不同 
8. $router和$route的区别
9. vue传参的三种方式 
10. flex布局 
11. 跨域的解决方案 
12. 线程和进程的区别 
13. 页面加载速度的优化方法 
14. canvas 怎么设置宽和高和style的宽高有什么区别 
15. 数组的函数方法 
16. MVC 
17. ref和$ref



#### 1.闭包(closure)[维基百科](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))

  * 基本概念：闭包是指有权访问另外一个函数作用域中变量的函数。  
  
  * 示例：
  
  ``` 
      var scope="global scope"; //全局变量
      function checkscope(){
          var scope="local scope"; //局部变量
          function f(){
              return scope; //在作用域中返回这值
          };
          return f();
      }
      checkscope(); //=>"local scope"
  ``` 
  
  * 说明：当一个函数嵌套了另一个函数，外部的函数将嵌套的函数对象作为返回值返回，就形成了闭包。函数定义在栈中，执行结束后内存会被释放掉，每次调用js函数的时候,都会为之创建一个新的对象来保存局部变量。闭包不同于普通的构造函数的地方在与局部变量会被保存下来。设想一下外部函数在调用之后内存被释放掉了，那么他的局部变量也就不存在了，这时候返回值是嵌套函数，嵌套函数需要return外部函数的变量。这个时候是不是就会报错，所以闭包就存在了。  

  * 实现原理:函数的作用域链


  * 闭包的用途:

    1. 私有化变量，避免全局污染; 
    2. 可访问函数内部的变量；

  * 闭包的缺点：会导致变量一直储存在内存中，过多会造成内存泄漏。

  * 闭包的应用  

    * 需要实现一个变量b的自增

``` 
     //可以实现自增，但是污染了全局变量
          var b = 10;
     function Add(){
         b++;
         console.log(b);
     }
     Add();
     Add();
     Add();
     
     //不污染全局，但是不能自增
          var b = 10;
     function Add2(){
         var b = 10;
         b++;
         console.log(b);
     }
     Add2();
     Add2();
     Add2();
     console.log(b);
     
     //完成实现
          var b  = 10;
     function Add3(){
         var b = 10;
         return function(){
             b++;
             return b;
         };
     };
     var cc =  Add3();
     console.log(cc());
     console.log(cc());
     console.log(cc());
     console.log(b);
```

#### 2.vue2和vue3双向绑定的区别

  * vue2  
  
   1. 实现原理：基于ES5中的 ` Object.defineProperty()`来实现双向绑定;

   2. 缺陷：对于对象无法检测property的添加和删除;对于数组无法通过索引修改数组项，无法修改数组length;
   
  * vue3  

   1. 实现原理：基于ES6的Proxy来实现双向绑定;

  * 官方解释： 
    
   1. vue2[链接](https://cn.vuejs.org/v2/guide/reactivity.html) 
   2. vue3[链接](https://v3.cn.vuejs.org/guide/reactivity.html) 


   #### 3.数组去重(2种) 

  * 将下列元素去除重复元素 
  ``` 
    const arr=[1,1,'abc','abc',true,true,undefined,undefined]; 
  ``` 

  * 方法1:Set()+Array.from() 
  ``` 
    const res=Array.from(new Set(arr)); 
    console.log(res);//[1, 'abc', true, undefined]
  ``` 

  * 方法2:利用filter()去重 
  ``` 
    let newArr = arr.filter(function(item,index){
      return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个  
    });
  ``` 

   #### 4.vueX 

  * Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 

  * 什么是单例模式 

   单例模式就是一个类只有一个实例; 


   #### 5.虚拟dom 

  * 什么是虚拟dom：虚拟dom就是一个普通的js对象。是一个用来描述真实dom的js对象,因为不是真实的dom,所以叫虚拟dom。 

  * 虚拟dom的作用 有什么好处？
   
   1. 相比传统的dom,使用模板引擎来渲染。虚拟dom会将diff函数处理过的内容储存到js当中，js中的dom对象改变之后再去绘制浏览器页面。

   ### 6.keep-alive 

  * 概念：keep-alive是vue的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。和transition相似，keep-alive是一个抽象组件：他自身不会渲染成一个dom元素，也不会出现在父组件链中。 

  * 作用：在组件切换过程中将状态保存在内存中，防止重新渲染dom,减少加载时间及性能消耗，提高用户体验。 

  * props:include-字符串或者正则表达式，只要匹配就会被缓存。 exclude-字符串或者正则表达式，只要匹配就不会被缓存。max-数字，最多可以缓存多少个组件实例。 

  * 生命周期： 
    1. activated:在keep-alive组件激活时使用，该钩子函数在服务器端渲染期间不会被调用。 

    2. deactivated:在keep-alive组件停用时调用，该钩子函数在服务端渲染期间不被调用。 


   #### 7.router里的history模式和hash模式有什么不同 

   在router.js中mode配置模式 
   ``` 
    const router = new VueRouter({
        mode: 'history',
        history: process.env.BASE_URL,
        routes // 可直接简写成routes:routes
    })
   ``` 

  * 前端路由的核心:就是在于改变视图的同时不向后端发出请求。 

  1. hash模式:  url有#,刷新页面可以跳转相应的页面,支持低版本浏览器和ie浏览器。

  2. history模式: url无#，一般都会404，h5新出的api,pushState与replaceState。 

   #### 8.$router和$route的区别 

  * $router: $router是VueRouter的一个实例，他包含了所有的路由，包括路由的跳转方法，钩子函数等，也包含一些子对象（例如history） 

  * $route: $route是一个跳转的路由对象（路由信息对象），每一个路由都会有一个$route对象，是一个局部的对象。 

   #### 9.路由传参的三种方式 

  1. params 传参（显示参数）又可分为 声明式 和 编程式 两种方式 

  ``` 
    <router-link :to="/child/1"> 跳转到子路由 </router-link>
  ``` 

  ``` 
    this.$router.push({
        path:'/child/${id}',
    })

  ``` 

  2. params传参（不显示参数）也可分为声明式和编程式两种方式 

  ``` 
    <router-link :to="{name:'Child',params:{id:1}}">跳转到子路由</router-link>

  ``` 

  ``` 
        this.$router.push({
            name:'Child',
            params:{
            id:1
            }
        })
  ``` 

  3. query 传参（显示参数）也可分为声明式和编程式 两种方式 

  ``` 
    <router-link :to="{name:'Child',query:{id:1}}">跳转到子路由</router-link>

  ``` 

  ``` 
        this.$router.push({
            name:'Child',
            query:{
            id:1
            }
        })
  ``` 
   #### 10 flex布局 

  * display属性 
   ``` 
    display:flex;
   ``` 
   设置display:flex属性表示flex布局。

  * flex-direction属性 
   控制主轴数据的排列方向 

  * 主轴与交叉轴 
  * justfy-content属性 
  * align-items属性 
  * flex-wrap属性 
  * flex-flow属性 
  * align-content属性 
  * align-self属性 
  * order属性 
  * flex-grow属性 
  * flex-shrink属性 
  * flex-basis属性 
  * flex属性 
  * row-gap与column-gap属性 
  * gap属性 

   #### 11 跨域的解决方案 

   #### 12 线程和进程的区别 

   #### 13 页面加载速度的优化方法 

   * 优化页面加载速度就三点 

   * 减少请求次数：有使用浏览器缓存来减少重复请求数据，避免重定向，减少DNS查询次数 ； 
   * 减小资源的大小：使用高压缩率的图片或者格式，使用CDN静态资源，压缩CSS和JS ； 
   * 服务器要快：开启网络压缩

   1. 优化图片资源的格式与大小 
   2. 开启网络压缩 
   3. 使用浏览器缓存 
   4. 减少重定向请求 
   5. 使用CDN存储静态资源 
   6. 减少DNS查询次数 
   7. 压缩CSS和JS 

   #### 14 canvas 怎么设置宽和高和style的宽高有什么区别 
   #### 15 数组的函数方法 

   1. unshift():在原数组前面添加一个或者多个元素，返回该数组的长度。 
   2. push():在原数组后面追加一个或者多个元素，返回该数组的长度。 
   3. shift():在原数组前面删除一个元素，返回该元素。 
   4. pop():在原数组后面删除一个元素，返回该元素

   #### 16 什么是MVVM 

   * MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。 view层是视图层，也就是用户界面。前端主要由html和css来构建；Model指的是数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是API接口；ViewModel是视图数据层，一个同步view和model的对象。 

   #### 16 什么是MVC
   
   * Model-View-Controler 

   #### 17 ref和$ref 

   * ref:被用来给元素或者子组件注册用户信息。引用信息将会注册到父组件的$refs对象上，如果在普通的DOM元素上使用，引用指向就是DOM元素。如果在子组件上引用，指向就是该子组件实例。 

   ``` 
   <p ref="p">Hello</p>
   <children ref="children"></children>    

   this.$refs.p
   this.$refs.children
   ``` 
   * this.refs:是一个对象，持有当前组件中注册过的ref特性的所有DOM元素和子组件实例。 

   * 注意： $refs只有在组件渲染完成后才填充，在初始渲染的时候不能访问它们，并且它是非响应式的，因此不能用它在模板中做数据绑定
